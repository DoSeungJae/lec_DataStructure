#include <stdio.h>

//과제 설명 : nxn(5x5) 크기의 행렬이 주어졌을 때 그 행렬의 전치행렬을 만드는 알고리즘을 C언어로 구현한다.

void Print_Mat(int arr[][5]);
void Transpos_Mat(int a[][5], int b[][5]);

int main(void) {
	int A[5][5] = { {3,2,6,4,5}, //원래 행렬
		{8,3,5,9,1},
		{0,3,2,7,9},
		{2,1,5,2,4},
		{5,0,8,2,3} };


	int B[5][5] = { {-1,-1,-1,-1,-1}, //전치행렬로 만들 행렬
	{-1,-1,-1,-1,-1},
	{-1,-1,-1,-1,-1},
	{-1,-1,-1,-1,-1},
	{-1,-1,-1,-1,-1} };

	Print_Mat(A); //행렬을 출력하는 함수

	Transpos_Mat(A, B);//B를 A의 전치행렬로 만드는 함수.

	Print_Mat(B);


	return 0;

}


void Print_Mat(int a[][5]) {
	for (int i = 0; i < 5; i++) {
		for (int j = 0; j < 5; j++) {
			printf("%d ", a[i][j]);
		}
		printf("\n");

	}
	printf("\n");
}




//전치행렬은 행과 열을 반대로 뒤집은 것이므로 만약 행렬 A의 j행i열에 a라는 숫자가 있다면 전치행렬 B에 a는 i행j열에
//위치한다. 따라서 행렬의 크기(5)만큼 2중 for문을 실행시켜 행렬 A에 j행i열의 숫자를 B행렬에 i행j열의 값으로 넣으면
//전치행렬을 만들 수 있다.
void Transpos_Mat(int a[][5], int b[][5]) {

	for (int i = 0; i < 5; i++) {
		for (int j = 0; j < 5; j++) {
			b[j][i] = a[i][j];
		}
	}

}

//원래행렬의 행이 전치행렬의 열이되고 원래행렬의 열이 전치행렬의 행이 된다는 것을 알면 쉽게 구현할 수 
//있는 알고리즘이다.
